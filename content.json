{"meta":{"title":"帅哥季的博客","subtitle":null,"description":null,"author":"liuxing7954","url":"https://liuxing7954.github.io/blog","root":"/blog/"},"pages":[{"title":"分类","date":"2019-07-05T07:50:36.000Z","updated":"2019-07-05T08:32:25.000Z","comments":true,"path":"categories/index.html","permalink":"https://liuxing7954.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-05T07:43:17.000Z","updated":"2019-07-05T08:32:25.000Z","comments":true,"path":"tags/index.html","permalink":"https://liuxing7954.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Effective-Java(1)","slug":"JAVA基础/Effective-Java(1)","date":"2019-07-05T09:37:05.000Z","updated":"2019-07-05T09:37:05.000Z","comments":true,"path":"2019/07/05/JAVA基础/Effective-Java(1)/","link":"","permalink":"https://liuxing7954.github.io/blog/2019/07/05/JAVA基础/Effective-Java(1)/","excerpt":"","text":"这是我阅读Effective-Java这本书做的笔记记录.希望能加深印象以后写的代码逼格能高一点 创建或销毁对象 设计一个类时,优先考虑是否能使用静态工厂方法123public static Boolean valueOf(boolean b) &#123; return (b ? TRUE : FALSE); &#125; 这样可以在重复使用对象时,减少对象的生成,也可以将构造方法转变成有名称意义的函数调用 一个类的初始化参数过多时,考虑使用Build方式创建 12345678910111213141516public class OuterClass&#123; OuterClass(Builder builder)&#123; // 从builder对象里取属性赋值... &#125; public static class Builder&#123; Builder(`这里传必须的参数`)&#123; &#125; // 其余可选参数用方法传入... public OuterClass build()&#123; return new OuterClass(this); &#125; &#125;&#125; 单例模式的实现考虑用枚举 1234567enum SomeClass&#123; INSTANCE; // 可选设置构造方法 // 定义属性... // 定义方法...&#125; 如果想类不被实例化,添加一个私有的构造方法 这个我觉得没什么鸟用,书中指的大概是工具类这样的类,这种类名字一看也就不会去实例化吧 如果&#39;工具类&#39;需要引用一些资源,而这些资源会变的,那就意味着这不应该是个静态工具类 可以用构造器传入这个资源具体的对象,也叫做依赖注入 避免创建多余的对象 复杂我还没理解,简单的一个场景就是自动装箱与拆箱,尽量都声明为基本类型可以避免创建多余封装对象 消除过期引用12345public Object pop() &#123; if (size == 0) throw new EmptyStackException(); return elements[--size]; &#125; 这段代码隐藏了一个OOM的错误,因为pop行为只减小了size的值而,elements数组中依然保留着对象的引用,这会导致对象不被回收,长期可能会OOM,解决办法是size减小的时候,将不用的引用置空 使用try-resources代替try-finnally1234567891011121314151617// try-finnallytry&#123;&#125;catch()&#123;&#125;finnally&#123;&#125;// try-resourcestry(`初始化`)&#123;&#125;catch()&#123;&#125;finnally&#123; &#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://liuxing7954.github.io/blog/categories/学习笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://liuxing7954.github.io/blog/tags/Java/"}]},{"title":"Java线程基础","slug":"Java多线程/Java线程基础","date":"2019-07-05T08:32:25.000Z","updated":"2019-07-05T08:32:25.000Z","comments":true,"path":"2019/07/05/Java多线程/Java线程基础/","link":"","permalink":"https://liuxing7954.github.io/blog/2019/07/05/Java多线程/Java线程基础/","excerpt":"","text":"线程的基本状态 初始化(New) 调用线程的start方法进入阶段2。 可运行(Runnable) 获得cpu时间片进入阶段3。 运行中 逻辑阶段，时间片暂时用完或者调用yield主动让出cpu（非强制性）回到阶段2。等待用户输入，或者sleep 会进入阶段4，主动调用wait方法，会进入阶段5。 阻塞阶段(Blocked) 阻塞的原因解除会回到可运行阶段 等待队列(Waiting) 这是一个不争取锁资源的队列，直到wait超时，或者被notify和notifyall方法唤醒，进入到阶段6。 锁池 等待争取锁，争取到锁就进入阶段2。 线程的主要方法使用Thread start 实际调用的native方法start0.此方法会真正的新起一个线程去执行run方法 run 仅仅是调用的runable对象的run方法，和线程一点关系都没有 yield 告诉调度器，此线程可以让出cpu时间，但是是否会切换执行线程，要看调度器的执行，所以这是个非强制的方法。 获取线程的返回值方案线程一般新建的方法是new Thread（new Runnable（）{}）; 这种集成自Runnable的线程实现不支持返回值 1234@FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125; Join方法 给继承自Runnable的实现类一个成员属性，然后run方法中给属性赋值，主线程中获取该值前调用线程的join方法去等待线程执行完毕 123456789101112public static class MyThread implements Runnable &#123; String name; @Override public void run() &#123; try &#123; Thread.currentThread().sleep(5000); name = \"jxy\"; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 12345678public static void main(String[] args) throws InterruptedException &#123; MyThread target = new MyThread(); Thread thread = new Thread(target); thread.start(); thread.join(); String name = target.name; System.out.println(name);&#125; Callable接口返回 12345678public static class MyCallable implements Callable &#123; @Override public Object call() throws Exception &#123; String name = \"jxy\"; Thread.currentThread().sleep(1000); return name; &#125;&#125; 1234567public static void main(String[] args) throws InterruptedException, ExecutionException &#123; MyCallable myCallable = new MyCallable(); FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(myCallable); new Thread(futureTask).start(); String name = futureTask.get(); System.out.println(name);&#125; wait和sleep的区别 wait是Object的方法，sleep是Thread的方法 sleep方法让出cpu执行时间，不释放锁，wait让出cpu时间和锁 wait让出锁的特性——所以只能在synchronized代码块或者方法中使用。 锁池和等待池线程中调用无参的wait方法，那就会进入无限期等待中(Waiting)也叫等待池（WaitSet）在这里的线程，释放了锁和让出cpu之后，不会去争取cpu时间,除非被notify和notifyall唤醒，重新进去锁池去争取锁。 notify和notifyall的区别这两个方法的区别在于notify随机唤醒一个等待池中的一个等待线程。notifyall唤醒全部等待线程 stop和interrupt的区别stop不安全已经废弃 interrupt是一个中断的通知，具体的中断由线程本身来执行 1234567891011121314151617public static void main(String[] args) throws InterruptedException, ExecutionException &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; try &#123; while (!isInterrupted()) &#123; System.out.println(\"thread 1\"); Thread.sleep(1000); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; thread.start(); thread.interrupt();&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://liuxing7954.github.io/blog/categories/学习笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://liuxing7954.github.io/blog/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://liuxing7954.github.io/blog/tags/多线程/"}]},{"title":"Java线程基础2","slug":"Java多线程/Java线程基础2","date":"2019-07-05T08:32:25.000Z","updated":"2019-07-05T08:32:25.000Z","comments":true,"path":"2019/07/05/Java多线程/Java线程基础2/","link":"","permalink":"https://liuxing7954.github.io/blog/2019/07/05/Java多线程/Java线程基础2/","excerpt":"","text":"synchronized的底层原理可重入锁synchronized是一个可重入锁，也就是已经获取锁对象，就可以重复使用 自旋锁自适应自旋锁","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://liuxing7954.github.io/blog/categories/学习笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://liuxing7954.github.io/blog/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://liuxing7954.github.io/blog/tags/多线程/"}]},{"title":"Spring-AOP使用说明","slug":"Spring/Spring-AOP使用说明","date":"2019-07-05T08:32:25.000Z","updated":"2019-07-05T08:32:25.000Z","comments":true,"path":"2019/07/05/Spring/Spring-AOP使用说明/","link":"","permalink":"https://liuxing7954.github.io/blog/2019/07/05/Spring/Spring-AOP使用说明/","excerpt":"","text":"名词解释实现原理使用方法切入点正则规则JdkProxy和Cglib","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://liuxing7954.github.io/blog/categories/学习笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://liuxing7954.github.io/blog/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://liuxing7954.github.io/blog/tags/Spring/"},{"name":"Spring-AOP","slug":"Spring-AOP","permalink":"https://liuxing7954.github.io/blog/tags/Spring-AOP/"}]},{"title":"Spring-IOC(1)-意义","slug":"Spring/Spring-IOC(1)-意义","date":"2019-07-05T08:32:25.000Z","updated":"2019-07-05T08:32:25.000Z","comments":true,"path":"2019/07/05/Spring/Spring-IOC(1)-意义/","link":"","permalink":"https://liuxing7954.github.io/blog/2019/07/05/Spring/Spring-IOC(1)-意义/","excerpt":"","text":"什么是IOCSpring Core 的核心部分 先行知识 – 依赖注入Dependency Inversion 使用情况一个上级依赖于下级的架构 1556338180523 如果最下级的Tire的成员变量size要改为动态化的，那架构图如下 1556338298535 问题不言而喻，所以优化后的架构应该是下层依赖于上层，即将下层的对象注入到上层中，将程序进行解耦。 优化后的架构为 1556338486389 此时再进行相同的需求改造时,只要改变Tire类的代码. 1556338534655 两者的差别很明显,耦合度后者更低,但是后者的初始化代码变的非常复杂. 为了解决这个问题,IOC容器内部隐藏了这些步骤.即将Luggage的初始化简化成前者情况的样子. IOC容器内部初始化一个对象的过程为 1556338766562","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://liuxing7954.github.io/blog/categories/学习笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://liuxing7954.github.io/blog/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://liuxing7954.github.io/blog/tags/Spring/"},{"name":"Spring-IOC","slug":"Spring-IOC","permalink":"https://liuxing7954.github.io/blog/tags/Spring-IOC/"}]},{"title":"Spring-IOC(2)-结构解析","slug":"Spring/Spring-IOC(2)-结构解析","date":"2019-07-05T08:32:25.000Z","updated":"2019-07-05T08:32:25.000Z","comments":true,"path":"2019/07/05/Spring/Spring-IOC(2)-结构解析/","link":"","permalink":"https://liuxing7954.github.io/blog/2019/07/05/Spring/Spring-IOC(2)-结构解析/","excerpt":"","text":"","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://liuxing7954.github.io/blog/categories/学习笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://liuxing7954.github.io/blog/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://liuxing7954.github.io/blog/tags/Spring/"},{"name":"Spring-IOC","slug":"Spring-IOC","permalink":"https://liuxing7954.github.io/blog/tags/Spring-IOC/"}]},{"title":"求合租","slug":"其他/寻合租舍友","date":"2019-07-05T08:32:25.000Z","updated":"2019-07-05T08:32:25.000Z","comments":true,"path":"2019/07/05/其他/寻合租舍友/","link":"","permalink":"https://liuxing7954.github.io/blog/2019/07/05/其他/寻合租舍友/","excerpt":"","text":"基本情况 丞相坊8号楼中层 1300元/月 水电网费另算 房子总大小64平 二室一厅一厨一卫一阳台(在主卧) 精装修 押一付一 入住可享受床,空调,洗衣机,冰箱,落地晾衣杆,宽带,沙发,客厅,可做饭,衣柜,阳台,热水器,卫生间,桌子,各种厨具,电脑椅,麻将桌 房间概况我是这套房子翻修后的第一批租客,墙壁地板都是全新的,之前的舍友已经换房子, 现在入住的押金也是给房东,出租的是主卧,附带阳台而且面积更大一些, 但房价还是一人一半.目前还没有涨价的消息. 租客要求男女皆可,一至二人皆可.主卧比较大,之前放一个气垫床可以住两人 实物图 客厅1 客厅2 待出租卧室 现在没人住所以堆积了一些东西, 其实只有床和衣柜和落地晾衣杆和桌子 联系方式 Tel: 18850107457 QQ: 467677527 微信: 同电话","categories":[{"name":"杂物","slug":"杂物","permalink":"https://liuxing7954.github.io/blog/categories/杂物/"}],"tags":[{"name":"已过期","slug":"已过期","permalink":"https://liuxing7954.github.io/blog/tags/已过期/"}]}]}